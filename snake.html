<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Worm</title>
  <style>
    body {
      background-color: black;
      color: white;
      margin: 0; 
      padding: 0;
      font-family: Arial, sans-serif;
    }
    /* Pale yellow (sand-like) background for the canvas */
    canvas {
      display: block;
      margin: 40px auto;
      border: 1px solid #fff;
      background: #0dd449; /* Light Goldenrod Yellow */
    }
  </style>
</head>
<body>

<canvas id="gameCanvas" width="400" height="400"></canvas>

<script>
// ---------------------------------------------------
// GLOBALS & SETUP
// ---------------------------------------------------
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

const gridSize = 20;
const cols = canvas.width / gridSize;
const rows = canvas.height / gridSize;

// Snake
let snake = [{ x: 200, y: 200 }];
let dx = 0, dy = 0; // velocity

// Apple
let appleX = 0, appleY = 0;

// Rocks
let rocks = [];
const rockCount = 5;

// Bombs
const baseBombSpawnChance = 0.01; // 1% base chance
let bombs = [];

// Game Over
let gameOver = false;
let causeOfDeath = "";
let finalLength = 0;

// ---------------------------------------------------
// EXPLOSION CONFIG
// ---------------------------------------------------
let explosionParticleCount     = 20; // number of particles per explosion
let explosionParticleBaseSpeed = 3;  // base speed (px/frame)
let explosionParticleBaseLife  = 10; // base lifespan in frames
let explosionParticleBaseSize  = 6;  // base size (px)

// Utility: ±20% random factor => returns value in [0.8..1.2]
function randomFactor20() {
  return 1 + (Math.random() - 0.5) * 0.4;
}

// ---------------------------------------------------
// INITIALIZE
// ---------------------------------------------------
document.addEventListener("keydown", handleKey);
spawnRocks(rockCount);
spawnApple();
setInterval(gameLoop, 100); // 10 FPS

// ---------------------------------------------------
// MAIN LOOP
// ---------------------------------------------------
function gameLoop() {
  if (!gameOver) {
    update();
  }
  draw();
}

// ---------------------------------------------------
// UPDATE LOGIC
// ---------------------------------------------------
function update() {
  // Move snake
  const head = {
    x: snake[0].x + dx,
    y: snake[0].y + dy
  };

  // Wrap edges
  if (head.x < 0) head.x = canvas.width - gridSize;
  else if (head.x >= canvas.width) head.x = 0;
  if (head.y < 0) head.y = canvas.height - gridSize;
  else if (head.y >= canvas.height) head.y = 0;

  snake.unshift(head);

  // Check apple
  if (head.x === appleX && head.y === appleY) {
    spawnApple();
  } else {
    snake.pop();
  }

  // Dynamic bomb chance: 0.01 plus 0.005 per snake segment beyond length 1
  const snakeLength = snake.length;
  const dynamicBombChance = baseBombSpawnChance + (snakeLength - 1) * 0.005;

  if (Math.random() < dynamicBombChance) {
    spawnBomb();
  }

  // Update bombs
  updateBombs();

  // Collisions:
  // 1) Self collision
  for (let i = 1; i < snake.length; i++) {
    if (head.x === snake[i].x && head.y === snake[i].y) {
      endGame("body collision");
      return;
    }
  }

  // 2) Rock collision
  for (let rock of rocks) {
    for (let sq of rock.squares) {
      if (head.x === sq.x && head.y === sq.y) {
        endGame("rock");
        return;
      }
    }
  }

  // 3) Bomb "touch to explode"
  for (let bomb of bombs) {
    // If the bomb is still in flash stage and the snake head is on it,
    // force the bomb to explode
    if (bomb.stage === "flash" && head.x === bomb.x && head.y === bomb.y) {
      bomb.stage = "explode";
      bomb.framesLeft = 0; // skip flash
      destroyRockSquares(bomb.x, bomb.y, 2);
      createExplosionParticles(bomb);
    }
  }
}

// ---------------------------------------------------
// APPLE SPAWNING
// ---------------------------------------------------
function spawnApple() {
  // Gather all free tiles
  const freeTiles = [];
  for (let c = 0; c < cols; c++) {
    for (let r = 0; r < rows; r++) {
      const tx = c * gridSize;
      const ty = r * gridSize;

      // skip if rock
      if (isRockTile(tx, ty)) continue;
      // skip if snake
      if (snake.some(seg => seg.x === tx && seg.y === ty)) continue;

      freeTiles.push({ x: tx, y: ty });
    }
  }

  if (freeTiles.length === 0) {
    console.warn("No free tiles for apple!");
    return;
  }

  const choice = freeTiles[Math.floor(Math.random() * freeTiles.length)];
  appleX = choice.x;
  appleY = choice.y;
}

// ---------------------------------------------------
// ROCK SPAWNING
// ---------------------------------------------------
function spawnRocks(count) {
  rocks = [];
  for (let i = 0; i < count; i++) {
    let placed = false;
    const maxAttempts = 200;

    for (let attempt = 0; attempt < maxAttempts && !placed; attempt++) {
      const w = 1 + Math.floor(Math.random() * 3);
      const h = 1 + Math.floor(Math.random() * 3);
      const xTile = Math.floor(Math.random() * (cols - w));
      const yTile = Math.floor(Math.random() * (rows - h));

      const squares = [];
      for (let rx = 0; rx < w; rx++) {
        for (let ry = 0; ry < h; ry++) {
          squares.push({
            x: (xTile + rx) * gridSize,
            y: (yTile + ry) * gridSize
          });
        }
      }

      // Check conflicts: snake + existing rocks
      if (squares.some(sq => snake.some(sg => sg.x === sq.x && sg.y === sq.y))) {
        continue;
      }

      let conflict = false;
      for (let rock of rocks) {
        for (let sq of rock.squares) {
          if (squares.some(cand => cand.x === sq.x && cand.y === sq.y)) {
            conflict = true;
            break;
          }
        }
        if (conflict) break;
      }
      if (!conflict) {
        rocks.push({ squares });
        placed = true;
      }
    }
  }
}

function isRockTile(x, y) {
  for (let rock of rocks) {
    for (let sq of rock.squares) {
      if (sq.x === x && sq.y === y) {
        return true;
      }
    }
  }
  return false;
}

// ---------------------------------------------------
// BOMB SPAWNING & UPDATING
// ---------------------------------------------------
function spawnBomb() {
  let bombX, bombY;
  let tries = 0;
  const maxTries = 200;

  do {
    bombX = Math.floor(Math.random() * cols) * gridSize;
    bombY = Math.floor(Math.random() * rows) * gridSize;
    tries++;
  } while (
    tries < maxTries &&
    ( (bombX === appleX && bombY === appleY) ||
      isRockTile(bombX, bombY) ||
      snake.some(seg => seg.x === bombX && seg.y === bombY))
  );

  bombs.push({
    x: bombX,
    y: bombY,
    stage: "flash",
    framesLeft: 20,
    particles: []
  });
}

function updateBombs() {
  for (let i = bombs.length - 1; i >= 0; i--) {
    let bomb = bombs[i];

    if (bomb.stage === "flash") {
      bomb.framesLeft--;
      if (bomb.framesLeft <= 0) {
        bomb.stage = "explode";
        destroyRockSquares(bomb.x, bomb.y, 2);
        createExplosionParticles(bomb);
      }
    } else if (bomb.stage === "explode") {
      // Update each particle
      for (let p = bomb.particles.length - 1; p >= 0; p--) {
        let part = bomb.particles[p];
        part.life--;
        part.x += part.dx;
        part.y += part.dy;

        if (part.life <= 0) {
          bomb.particles.splice(p, 1);
          continue;
        }

        // check collision with snake
        if (checkParticleCollisionWithSnake(part)) {
          endGame("bomb");
          return;
        }
      }
      if (bomb.particles.length === 0) {
        bombs.splice(i, 1);
      }
    }
  }
}

function destroyRockSquares(bx, by, radius) {
  const bombTileX = bx / gridSize;
  const bombTileY = by / gridSize;

  for (let r = rocks.length - 1; r >= 0; r--) {
    let rock = rocks[r];
    rock.squares = rock.squares.filter(sq => {
      const tx = sq.x / gridSize;
      const ty = sq.y / gridSize;
      const dist = Math.sqrt((tx - bombTileX)**2 + (ty - bombTileY)**2);
      return dist > radius;
    });
    if (rock.squares.length === 0) {
      rocks.splice(r, 1);
    }
  }
}

// Create explosion particles with randomization
function createExplosionParticles(bomb) {
  bomb.particles = [];
  for (let i = 0; i < explosionParticleCount; i++) {
    const angle = Math.random() * 2 * Math.PI;

    // Speed with ±20% variation
    const speed = explosionParticleBaseSpeed * randomFactor20();

    // Lifespan with ±20% variation
    const maxLife = Math.floor(explosionParticleBaseLife * randomFactor20());

    // Size with ±20% variation
    const size = explosionParticleBaseSize * randomFactor20();

    const dx = Math.cos(angle) * speed;
    const dy = Math.sin(angle) * speed;

    bomb.particles.push({
      x: bomb.x + gridSize / 2,
      y: bomb.y + gridSize / 2,
      dx,
      dy,
      life: maxLife,
      maxLife,
      size
    });
  }
}

function checkParticleCollisionWithSnake(p) {
  for (let part of snake) {
    const cx = part.x + gridSize/2;
    const cy = part.y + gridSize/2;
    const distX = cx - p.x;
    const distY = cy - p.y;
    if (Math.sqrt(distX*distX + distY*distY) < 10) {
      return true;
    }
  }
  return false;
}

// ---------------------------------------------------
// DRAW
// ---------------------------------------------------
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (!gameOver) {
    // Snake
    ctx.fillStyle = "lime";
    snake.forEach(s => ctx.fillRect(s.x, s.y, gridSize, gridSize));

    // Apple
    ctx.fillStyle = "red";
    ctx.fillRect(appleX, appleY, gridSize, gridSize);

    // Rocks
    ctx.fillStyle = "gray";
    rocks.forEach(rock => {
      rock.squares.forEach(sq => ctx.fillRect(sq.x, sq.y, gridSize, gridSize));
    });

    // Bombs
    drawBombs();
  } else {
    drawGameOverScreen();
  }
}

function drawBombs() {
  bombs.forEach(bomb => {
    if (bomb.stage === "flash") {
      // flash black/white every 5 frames
      const totalFlash = 20;
      const elapsed = totalFlash - bomb.framesLeft;
      const phase = Math.floor(elapsed / 5);
      ctx.fillStyle = (phase % 2 === 0) ? "white" : "black";
      ctx.fillRect(bomb.x, bomb.y, gridSize, gridSize);
    } else if (bomb.stage === "explode") {
      bomb.particles.forEach(p => {
        const fraction = 1 - (p.life / p.maxLife);
        let color = "white";
        if (fraction > 0.66) color = "red";
        else if (fraction > 0.33) color = "yellow";

        ctx.fillStyle = color;
        const half = p.size / 2;
        ctx.fillRect(p.x - half, p.y - half, p.size, p.size);
      });
    }
  });
}

// ---------------------------------------------------
// GAME OVER & RESET
// ---------------------------------------------------
function endGame(reason) {
  gameOver = true;
  causeOfDeath = reason;
  finalLength = snake.length;
}

function drawGameOverScreen() {
  // Fill the canvas with black for contrast
  ctx.fillStyle = "black";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "white";
  ctx.textAlign = "center";
  ctx.font = "20px Arial";

  ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 40);
  ctx.fillText("Final Length: " + finalLength, canvas.width / 2, canvas.height / 2);
  ctx.fillText("Cause of Death: " + causeOfDeath, canvas.width / 2, canvas.height / 2 + 40);
  ctx.fillText("Press Enter to Restart", canvas.width / 2, canvas.height / 2 + 80);
}

function handleKey(e) {
  if (!gameOver) {
    switch(e.key) {
      case "ArrowUp":
        if (dy === 0) { dx = 0; dy = -gridSize; }
        break;
      case "ArrowDown":
        if (dy === 0) { dx = 0; dy = gridSize; }
        break;
      case "ArrowLeft":
        if (dx === 0) { dx = -gridSize; dy = 0; }
        break;
      case "ArrowRight":
        if (dx === 0) { dx = gridSize; dy = 0; }
        break;
    }
  } else {
    if (e.key === "Enter") {
      resetGame();
    }
  }
}

function resetGame() {
  gameOver = false;
  causeOfDeath = "";
  finalLength = 0;
  snake = [{ x: 200, y: 200 }];
  dx = 0;
  dy = 0;
  bombs = [];
  rocks = [];

  spawnRocks(rockCount);
  spawnApple();
}
</script>

</body>
</html>
